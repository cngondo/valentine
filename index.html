<!DOCTYPE html>
<html lang="en">
  <head>
    <title>For: Tom Babe</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #f0f0f0;
        color: white;
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>

  <audio autoplay>
    <source src="sauti.mp3" type="audio/mpeg">
  Your browser does not support the audio element.
  </audio>

    <script src="three.min.js"></script>

    <script>

      var container;

      var camera, scene, renderer,camin;

      var group;

      var targetRotation = 0;
      var targetRotationOnMouseDown = 0;

      var mouseX = 0;
      var mouseXOnMouseDown = 0;

      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;

      init();
      animate();

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        var info = document.createElement( 'div' );
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.innerHTML = 'Happy Valentine\'s day Tom<br />Thank you for your love and all that you do - I love you<br/>(Drag with your mouse to spin the hearts)';
        container.appendChild( info );

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set( 0, 150, 500 );
        scene.add( camera );

        var light = new THREE.PointLight( 0xffffff, 0.8 );
        camera.add( light );

        group = new THREE.Group();
        group.position.y = 50;
        scene.add( group );

        var loader = new THREE.TextureLoader();
        var texture = loader.load( "alt.jpg" );

        // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.flipY = false;
        texture.repeat.set( 0.01, 0.01 );

        var texture2 = loader.load( "holding.jpg" );

        // it's necessary to apply these settings in order to correctly display the texture2 on a shape geometry

        texture2.wrapS = texture2.wrapT = THREE.RepeatWrapping;
        texture2.flipY = false;
        texture2.repeat.set( 0.01, 0.01 );


        function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {

          // flat shape with texture
          // note: default UVs generated by ShapeBufferGemoetry are simply the x- and y-coordinates of the vertices

          var geometry = new THREE.ShapeBufferGeometry( shape );

          var mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } ) );
          mesh.position.set( x, y, z - 175 );
          mesh.rotation.set( rx, ry, rz );
          mesh.scale.set( s, s, s );
          group.add( mesh );

          // flat shape

          var geometry = new THREE.ShapeBufferGeometry( shape );

          var mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color, side: THREE.DoubleSide } ) );
          mesh.position.set( x, y, z - 125 );
          mesh.rotation.set( rx, ry, rz );
          mesh.scale.set( s, s, s );
          group.add( mesh );

          // extruded shape

          var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

          var mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture2 } ) );
          mesh.position.set( x, y, z - 75 );
          mesh.rotation.set( rx, ry, rz );
          mesh.scale.set( s, s, s );
          group.add( mesh );

          // lines

          shape.autoClose = true;
          var points = shape.createPointsGeometry();
          var spacedPoints = shape.createSpacedPointsGeometry( 50 );

          // solid line

          var line = new THREE.Line( points, new THREE.LineBasicMaterial( { color: color, linewidth: 3 } ) );
          line.position.set( x, y, z - 25 );
          line.rotation.set( rx, ry, rz );
          line.scale.set( s, s, s );
          group.add( line );

          // line from equidistance sampled points

          var line = new THREE.Line( spacedPoints, new THREE.LineBasicMaterial( { color: color, linewidth: 3 } ) );
          line.position.set( x, y, z + 25 );
          line.rotation.set( rx, ry, rz );
          line.scale.set( s, s, s );
          group.add( line );

          // vertices from real points

          var particles = new THREE.Points( points, new THREE.PointsMaterial( { color: color, size: 4 } ) );
          particles.position.set( x, y, z + 75 );
          particles.rotation.set( rx, ry, rz );
          particles.scale.set( s, s, s );
          group.add( particles );

          // equidistance sampled points

          var particles = new THREE.Points( spacedPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
          particles.position.set( x, y, z + 125 );
          particles.rotation.set( rx, ry, rz );
          particles.scale.set( s, s, s );
          group.add( particles );

        }

        // Heart

        var x = 0, y = 0;

        var heartShape = new THREE.Shape(); // From http://blog.burlock.org/html5/130-paths

        heartShape.moveTo( x + 25, y + 25 );
        heartShape.bezierCurveTo( x + 25, y + 25, x + 20, y, x, y );
        heartShape.bezierCurveTo( x - 30, y, x - 30, y + 35,x - 30,y + 35 );
        heartShape.bezierCurveTo( x - 30, y + 55, x - 10, y + 77, x + 25, y + 95 );
        heartShape.bezierCurveTo( x + 60, y + 77, x + 80, y + 55, x + 80, y + 35 );
        heartShape.bezierCurveTo( x + 80, y + 35, x + 80, y, x + 50, y );
        heartShape.bezierCurveTo( x + 35, y, x + 25, y + 25, x + 25, y + 25 );


        var extrudeSettings = { amount: 8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
        // addShape( shape, color, x, y, z, rx, ry,rz, s );
        addShape( heartShape, extrudeSettings, 0xf00000, 60, 100, 0, 0, 0, Math.PI, 1 );


        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );


        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        //

        window.addEventListener( 'resize', onWindowResize, false );



        var campo= true;


        camin = function(){

          if(campo==true){
              if(camera.position.z>0){
                camera.position.z-=1;
              }
              else {
                campo = false;
                camout()
              }
          } else if(campo==false){
            camout();
          }
        }

        function camout(){
          if(camera.position.z<400){
            camera.position.z+=1;
          }
          else{
            campo=true;
          }
        }

      }

      function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      //

      function onDocumentMouseDown( event ) {

        event.preventDefault();

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        document.addEventListener( 'mouseout', onDocumentMouseOut, false );

        mouseXOnMouseDown = event.clientX - windowHalfX;
        targetRotationOnMouseDown = targetRotation;

      }

      function onDocumentMouseMove( event ) {

        mouseX = event.clientX - windowHalfX;

        targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;

      }

      function onDocumentMouseUp( event ) {

        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

      }

      function onDocumentMouseOut( event ) {

        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

      }

      function onDocumentTouchStart( event ) {

        if ( event.touches.length == 1 ) {

          event.preventDefault();

          mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
          targetRotationOnMouseDown = targetRotation;

        }

      }

      function onDocumentTouchMove( event ) {

        if ( event.touches.length == 1 ) {

          event.preventDefault();

          mouseX = event.touches[ 0 ].pageX - windowHalfX;
          targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

        }

      }

      //

      function animate() {

        requestAnimationFrame( animate );

        render();

      }

      function render() {
        camin();
        group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
        renderer.render( scene, camera );

      }



    </script>

  </body>
</html>
